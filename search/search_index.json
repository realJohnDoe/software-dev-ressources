{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software Development Ressources","text":""},{"location":"#welcome-to-my-notes-on-software-development","title":"Welcome to my Notes on Software Development","text":"<p>I am collecting some notes and ressources on different software development topics, sometimes with a summary.</p> <p>If you have feedback, let me know!\ud83d\ude42</p>"},{"location":"ci-cd/","title":"CI/CD","text":"<ul> <li>Ship, Show, Ask - a modern branching strategy</li> <li>Continuous Integration in Automotive (Paywall)</li> </ul>"},{"location":"dora/","title":"DORA metrics","text":"<ul> <li>Deployment frequency</li> <li>Lead Time for Changes</li> <li>Mean Time to Recovery</li> <li>Change Failure Rate</li> </ul>"},{"location":"modern-software-development/","title":"Modern Software Engineering","text":"<p>In the book, David tries to figure out concepts that prooved successful in the last decades of Software Development and thus could help to move our business from a craft to a serious engineering discipline. He sorts those concepts by two main goals \"Optimize for Learning\" and \"Optimize for Managing Complexity\". The resulting groups, which are also the chapters of the main part of the book are:</p> <ul> <li>for Learning:</li> <li>Working Iteratively</li> <li>Feedback</li> <li>Incrementalism</li> <li>Empiricism</li> <li>Being Experimental</li> <li>for Managing Complexity:</li> <li>Modularity</li> <li>Cohesion</li> <li>Separation of Concerns</li> <li>Information Hiding and Abstraction</li> <li>Managing Coupling</li> </ul> <p>While none of those concepts are new, it is the first time I saw them put into context like this and also backed up with good arguments as well as some data.</p> <p>The book then ends with giving some tools to improve the above concepts:</p> <ul> <li>Test-Driven Development</li> <li>Ensuring Deployability</li> <li>and Speed: He recommends a maximum of five minutes from commit to test results   and one hour from commit to deployment.</li> </ul> <p>Even though the read was a bit repetitive since there is some overlap between the different topics, I found it very inspiring and motivating to try out the presented ideas.</p>"},{"location":"paradigms.functional/","title":"Functional Programming","text":"<ul> <li>Bartosz Milewski: Category Theory for Programmers</li> <li>Functional programming design patterns by Scott Wlaschin</li> <li>OOP - Does functional programming replace GoF design patterns?)</li> </ul>"},{"location":"tdd-where-did-it-all-go-wrong/","title":"TDD - Where Did It All Go Wrong?","text":"<p>Link to the video</p>"},{"location":"tdd-where-did-it-all-go-wrong/#motivation","title":"Motivation","text":"<ul> <li>Staying for longer than 2 years makes it possible to learn from mistakes that   you would otherwise not have noticed.</li> <li>Having much more test code than implementation seems a bit weird.</li> <li>Tests with many mocks tend to break when refactoring, which seems wrong.   Changing the implementation details should not require the tests to change.</li> <li>\"Programmer Anarchy\" is about developing products with only developers.</li> <li>Tests whose intent is unclear should be a warning sign. For example tests that   only test mocks and no acutal code.</li> <li>Large Acceptance Tests are often red for a significant amount of time, without   the devs knowing if they are broken, due to unimplemented features or due to   bugs.   =&gt; Developers started ignoring them and did not want to write them.   This not changing even after a long time, is also a warning sign.</li> </ul>"},{"location":"tdd-where-did-it-all-go-wrong/#what-did-go-wrong","title":"What did go wrong?","text":"<ul> <li>\"Test-Driven Development\" by Kent Beck seems alright, maybe we overloaded the   concept with other, less helpful concepts.   It already has answers for many issues we face with TDD today.   For examples: <p>Avoid testing implementation details, test behaviors</p> </li> <li>=&gt; Focus on testing the public API, i.e.</li> <li>the \"exports\" from a module</li> <li> <p>The system under test is not a class</p> </li> <li>The SUT is the \"exports\" from a module</li> <li>The old \"unit\" means a module, not a \"class\"</li> <li>Refactoring is a key step to distinguish stuff implementation details and     stable interfaces, \"behaviors\"</li> <li>Definition of unit is how the product can be separated so it can be tested in   parallel.</li> <li>Accessing the file system or a database is bad because it makes the tests     less independent, and it improves speed.     If both are no issue, it is okay to access external systems during testing.</li> </ul>"},{"location":"architecture/architecture.arc42/","title":"arc42","text":"<p>arc42 - arc42</p>"},{"location":"architecture/architecture.clean.go-app-structure/","title":"How do you structure your Go Apps","text":"<ul> <li>Speaker: Kat Zien</li> <li> <p>https://www.youtube.com/watch?v=oL6JBUk6tj0</p> </li> <li> <p>\"Hexagonal\" vs MVC levels</p> </li> <li>Have a pkg directory for binaries</li> <li>similar to onion / clean architecture</li> </ul>"},{"location":"architecture/architecture.clean/","title":"Clean Architecture","text":"<p>by Bob Martin https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</p> <ul> <li> <p>A quick introduction to clean architecture</p> </li> <li> <p>Hexagonal Architecture</p> </li> </ul>"},{"location":"architecture/architecture/","title":"Architecture","text":"<ul> <li>Structurizr</li> <li>C4 Model Tooling</li> <li>Structurizr</li> </ul>"},{"location":"architecture/architecture.software-architecture-vs-code/","title":"Software Architecture vs. Code","text":"<p>GOTO 2014 \u2022 Software Architecture vs. Code \u2022 Simon Brown</p>"},{"location":"architecture/architecture.why-architecture-comes-before-coding/","title":"Why Architecture Comes before Coding","text":"<p>GOTO 2021 \u2022 Why Architectural Work Comes Before Coding \u2022 Simon Brown &amp; Stefan Tilkov</p>"},{"location":"languages/python/python/","title":"Python","text":"<ul> <li>pydeps \u00b7 PyPI</li> </ul>"},{"location":"languages/python/python.minus-m-pip/","title":"Why you should use `python -m pip`","text":"<p>article</p>"},{"location":"languages/python/python.package-managers/","title":"Package Managers","text":"<p>article</p>"},{"location":"languages/rust/compile-times/","title":"Rust vs C++ Compile Times","text":"<p>article</p>"},{"location":"languages/rust/integers/","title":"Integers","text":"<ul> <li> <p>Be careful when converting number types of different range, such as <code>i32</code>   and <code>u32</code>.</p> </li> <li> <p><code>usize</code> marks the integer size of a memory pointer.</p> </li> <li> <p>There are <code>saturating_</code> functions for integers that ensure to not exceed their   range when adding / subtracting.</p> </li> </ul>"},{"location":"languages/rust/property-based-testing-in-rust-with-arbitrary/","title":"Property Based Testing in Rust with Arbitrary","text":"<p>property-testing</p> <ul> <li><code>Arbitrary</code> trait allows to generate valid objects from random bytes</li> <li> <p><code>arbtest</code> can be used to run tests with <code>Arbitrary</code> objects</p> </li> <li> <p>requires a helper function that will get executed multiple times</p> </li> </ul>"},{"location":"languages/rust/rust/","title":"Rust","text":"<ul> <li> <p><code>to_owned</code>: goes from borrowed to owned, usually by implementing the clone   trait.</p> </li> <li> <p>The difference between arrays and slices is that arrays have a fixed size   and are denoted with <code>[T, n]</code> or <code>&amp;[T, n]</code> while slices have a variable   size and are denoted with <code>[T]</code> or <code>&amp;[T]</code>.</p> </li> <li> <p>Slices</p> </li> <li> <p>have a <code>.windows(n)</code> method that returns all possible windows of length <code>n</code> for that slice.</p> </li> <li> <p>have a <code>.any(predicate) bool</code> method that returns true if any of the     contained ites evaluates true under the predicate.</p> </li> <li> <p>have a <code>.len()</code> and a <code>.is_empty()</code> method.</p> </li> <li> <p>Lambdas can be defined with a <code>|x, y| x*y</code> syntax.</p> </li> <li> <p><code>match</code> can receive mutliple values, like</p> </li> </ul> <pre><code>match (a, b) {\ntrue, false =&gt; {},\n...\n}`\n</code></pre> <ul> <li> <p>We can use <code>||</code> syntax to return a first simple expression and forward to a   more complex expression in case the first one is false.</p> </li> <li> <p>The crate <code>int_enum</code> can be used to build integer-valued enums with the syntax</p> </li> </ul> <pre><code>#[repr(usize)]\n#[derive(Clone, Copy, Debug, PartialEq, Eq, IntEnum)]\nenum Colors {\nRed = 1,\nBlue = 2\n}\n\nlet red = Color::from_int(1).expect(\"value out of range\");\nlet int_value = red.int_value();\n</code></pre> <ul> <li> <p>The crate <code>enum_iterator</code> can be used to iterate over enums.</p> </li> <li> <p><code>?</code> can be used to unwrap a result, only use it when it is ok and pass the   error up otherwise.</p> </li> <li> <p><code>.expect()</code> can be used to reformat a Result or Optional</p> </li> <li> <p>Structs</p> </li> <li> <p>Struct construction is done via <code>Struct { member_1, member_2 }</code>.</p> </li> <li> <p>The class itself can be referenced in methods via <code>Self</code> while the instance     can be accessed using <code>self</code></p> </li> <li> <p><code>Iterator</code> trait objects</p> </li> <li> <p>have a method <code>step_by</code> which allows to skip some items.</p> </li> <li> <p>have a method <code>filter_map</code> to do filtering and mapping in one go.</p> </li> <li> <p>We can use <code>|(a, _)| a % 2 == 0</code> syntax to combine pattern matching and a   lambda function.</p> </li> <li> <p><code>map</code> can be used on <code>Option</code> to run function on the <code>Some</code> case</p> </li> <li> <p>bools can be converted to an <code>Option</code> by using <code>.then()</code> or <code>then_some()</code>.</p> </li> <li> <p>Traits can be combined with <code>+</code>.\ud83e\udd2f</p> </li> <li>The <code>std::cmp::Eq</code> trait and <code>std::hash::Hash</code> traits are required for HashMap   keys.</li> <li> <p>The <code>std::cmp::Ord</code> trait is required for comparing.</p> </li> <li> <p>HashMap entries</p> </li> <li> <p>can be set with <code>.insert()</code></p> </li> <li>can be retrieved with <code>.get()</code> or</li> <li>modified with <code>.get_mut()</code>.</li> <li> <p>can be modified in place with <code>.entry()</code></p> </li> <li> <p><code>Iter</code> vs <code>IntoIterator</code> traits :</p> </li> <li> <p><code>IntoIterator</code> is required for <code>for</code>-loops, but yields values, immutable     references or mutable references depending on context.</p> </li> <li> <p><code>Iter</code> yields immutable references.</p> </li> <li> <p><code>map().all(|x| x)</code> can be simplified to <code>all()</code></p> </li> <li> <p><code>.unwrap_or</code> can be used on <code>Option</code> to easily define a default in the <code>None</code>   case.</p> </li> <li> <p><code>vec![0; 5]</code> can be used to create a vector of five zeroes.</p> </li> <li> <p><code>vec![1, 2, 3]</code> will compile into a vector with elements 1, 2, and 3.</p> </li> <li> <p>Don't put a semicolon <code>;</code> at the end of lines if the value shall be returned.</p> </li> <li> <p><code>Vec</code> elements can be accessed and modified using square brackets <code>[]</code>.</p> </li> <li> <p>A range can be defined using <code>1..4</code>.   The last value will not be included.</p> </li> </ul>"}]}